{
  "name": "Counter",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "proposal",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "admin",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+Xd55NTVRjH8SywiV2s7FKX3hbI3SS7iXXF3rGLFSJZu2IXK2Lv2AsWwN47f57j8525jDqjr/bsDGe+d+Y3992dfG6SW895nn2VSmVP5e+lr1yPl+v65JaiP7bR/x/bbdRHm83e2EivaBSb6yOdbrtVb7a6o+2iXbTarS0j7Uaj1262xzrdzli9UzQbvWKi1WlMlBvuT/cZ61PhrsY2qlPgrh7g7lpsozYF7lpi9//93if7OQcTfs6+cl8OldubFfkzMlCuB2Xr4cjs8jtjv8ws98vsA+Bzzan8e5lWrsfLdX1yS9FXSfcbnVuZmv9SavO0hOZ5mZinJzTPz8Q8I6F5QSbm/oTmoUzM1YTmhZmYawnNizIxz0loXpyJeTCheYnQvFRoXiY0LxeaVwjNK4XmVULzaqF5WGheIzSvFZrXCc11obkQmkeE5obQ3BSaW0LzqNA8JjS3heaO0HyC0Hyi0HyS0Hyy0HyK0Hyq0DwuNJ8mNK8Xmk8Xms8Qms8Ums8Sms8Wms8Rms8Vms8Tms8Xmi8Qmi8Umi8Smi8WmjcIzZcIzZcKzZcJzZcLzVcIzVcKzVcJzVcLzRuF5muE5muF5uuE5uuF5huE5huF5k1C82ahuSs03yQ0bxGae0LzhNB8s9B8i9B8q9B8m9B8u9B8h9B8p9B8l9B8t9C8VWi+R2i+V2i+T2i+X2h+QGh+UGh+SGh+WGjeJjQ/IjQ/KjQ/JjQ/LjQ/ITQ/KTRvF5qfEpp3CM1PC83PCM3PCs3PCc3PC80vCM0vCs0vCc0vC82vCM2vCs2vCc2vC807heY3hOY3hea3hOa3heZ3hOZ3heb3hOb3heYPhOYPheZdQvNHQvPHQvMnQvOnQvNuoXmP0LxXaP5MaP5caP5CaP5SaP4qE/NBCc1fZ2I+OKH5m0zMhyQ0f5uJ+dCE5u8yMR+W0Px9JubDE5p/yMR8RELzj5mYj0xo/ikT88yE5p8zMR+V0PxLJuajE5p/zcR8TELzb5mYj01o/j0T83EJzX9kYj4+oXlfQvNAuZ2+0jw9MiPSH6lGahHuCblH4p6Ba2iuKbnG4pqDczDnJI7RHLP4D/Ob5jvGPCsy8I/9uqtcz43Mi8yPLIgMRRZGFkUWR5ZElkaWRZZHVkRWRlZFVkeGI2siayPr2A+RIkKve3q/0wud3uD0yqZ3NL2UOxF67dJ7ll6s9CalV+f+3pX0NlwfofcdveDojUavMHpn0UuK3kr0GqL3Dr1o6M1CrxJ6d2yI0NuBXgfU/qcWPrXhqZVO7XBqaW+MUGuZ2sPU4qU2LbVaqV26KUJty26E2ofUAqQ2HrXiqJ1GLTFqa1FritpL1CKiNg+1aqjdsjVCbQ9qXVD7gVoI1AZgrjxzx5lLvS3CXFvmnjIXk7mJzNVj7tr2CHObdkSY+8JcEOZGMFeAsfOMJWdsNWONGXvLWFTGZjJWkbF7OyOM7WKsE2N/GAvD2BDGSjB2gHfpvFvmXSu/Ad7F8W6KdzW8u9gd4dn23gjPPnkWyLMxnhXx7IRnCdxbc6/JvRf3Ilybc63KtRvXMpzbOddx7OdYyLGB/8r+5S+pnj1t9JsAAA==",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_vote",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "vote",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "integer",
          "sign": "unsigned",
          "width": 120
        }
      ],
      "bytecode": "H4sIAAAAAAAA/82W206DQBCGl0OhSxGL95p9ggZ6Z+IFvoI+AUnRGyoJYPTx7dKZ+HfdGJMuqZPQHXa2838zy8kXQnjiaAH4aDxX0VicZ6XnLleBvP7heCRf0jlaBH7lSD9y359iAazSqE9bRvHQre5W0jVg23uzbwL0NcvCLcvU18hxfTpHDPxcK7OvIB7BGLvlmK7/hTjtKZ8j319Z/QuzzrX/S7c5tynl5F4ujZ5iPYnjenQOvpdD0EpAM51h71aUy6ODNSToXs2gm0JvkYO1AlhzBzFeZ+7HHL1Bq8BnLWTxLswixc9nsYR4DHO+8V+9B/cQz8j3LXkyyzqs/XqG2lGngnPWSoAh+wcssYVl7ZZlel7k4tt4f9bAwUw5cNw45vAMjk/QZS0Jfg5zvrEuJsbALWM5w/un1PyhOLXf7lPW1+8Ufm4MY9fXr81TU+88SBEa6fAzFf0AWsmfIyHM4WtfWywsn+8VjcV5VmIBwlKALX5L4wONz8d+qKHtRlWot8Nv3bbdR7PbKIwNav8+jGoY635UL323V+XmCz47d9CoDAAA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "vote",
      "functionType": "open",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "vote",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "aztec::abi::PublicCircuitPublicInputs",
          "fields": [
            {
              "name": "call_context",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::CallContext",
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "portal_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_contract_deployment",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            },
            {
              "name": "args_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "return_values",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "contract_storage_update_requests",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageUpdateRequest",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "old_value",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "new_value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "contract_storage_read",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageRead",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "public_call_stack",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_commitments",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_nullifiers",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_l2_to_l1_msgs",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_logs_hash",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_log_preimages_length",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "block_data",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::HistoricBlockData",
                "fields": [
                  {
                    "name": "note_hash_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nullifier_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "contract_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "l1_to_l2_messages_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "blocks_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "public_data_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "global_variables_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "prover_address",
              "type": {
                "kind": "field"
              }
            }
          ]
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d+O7MZxx/F3OddCMPW3i3qVIBdG4gAGDDuIfWfo3T0GNLMySC0ldJ/ll2RfxQFmz/y6GltdpPZD/uPbn//633/4+5/++pe/ffvxH98e/7F8+/E///Htb//3h7/86///29//8P9///bj44dvf/zL/zz/708/fPvfP/35j99+lJ9+WH1KXdJ+/uTzf7f2/rTrxsefH3h9+PHxD1v+9F8/PHPIgxJEKEGUEsQoQZwSJChBkhKkUYIUJQilsyqlsyqlsyqlsyqlsyqlsyqlsyqlsyqlsyqlsyqlsxqlsxqlsxqlsxqlsxqlsxqlsxqlsxqlsxqlsxqlszqlszqlszqlszqlszqlszqlszqlszqlszqlszqlswalswalswalswalswalswalswalswalswalswalsyalsyalsyalsyalsyalsyalsyalsyalsyalsyalszZKZ22UztoonbVROmujdNZG6ayN0lkbpbM2SmdtlM5alM5alM5alM5alM5alM5alM5alM5alM5alM5alM66UDrrQumsC6WzLpTOulA660LprAulsy6UzrpQOutC6azyoLRWeVB6qzwozVUelO4qD0p7lQelv8qD0mDlQemw8qC0WHlgeiyIY2F6LAdkcUQWh2RxTBYHZXFUFodlYVyWYGCWYGSWYGiWYGyWYHCWYHSWYHiWYHyWYICWYISWYIiWYIyWYJCWYJSWYJiWYJyWYKCWYKSWYKiWYKyWYLCWYLSWYLiWYLyWYMCWYMSWYMiWYMyWYNCWYNSWYNiWYNyWYOCWYOSWYOiWYOyWYPCWYPSWYPiWYPyWYACXYASXYAiXYAyXYBCXYBSXYBiXYByXYCCXYCSXYCiXYCyXYDCXYDSXYDiXYDyXYECXYESXYEiXYEyXYFCXYFSXYFiXYFyXYGCXYGSXYGiXYGyXYHCXYHSXYHiXYHyXYICXYISXYIiXYIyXYJCXYJSXYJiXYJyXYpyXYpyXYpyXYpyXPig9VjHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOyzDOyzDOyzDOyzDOyx6UHmsY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY52UY5+UY5+UY5+UY5+UY5+UPSo91jPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPNyjPMKjPMKjPMKjPMKjPOKB6XHBsZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5BcZ5JcZ5JcZ5JcZ5JcZ55YPSYxPjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBLjvBrGeTWM82oY59Uwzqs9KD22YZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOdVGOdVGOdVGOdVGOdVD0qPLYzzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzKozzWjDOa8E4rwXjvBaM81oelB67YJzXgnFeC8Z5LRjntWCc14JxXgvGeS0Y57VgnNeCcV4LxnktGOe1YJzXgnFeC8Z5LRjntWCc14JxXgvGeS0Y57VgnNeCcV4LxnktGOe1YJzXgnFeC8Z5LRjntWCc14JxXkuf83r+k+8kKt6XpKvHDk3S1WOHJunqsUOTdPXYkUn6nNfQJF09dmiSrh47NElXjx2apKvHDk2C6bF9zmtoEkyP7XNeQ5Ngemyf8xqaBNNj+5zX0CSYHtvnvIYmwfTYPuc1NAmmx/Y5r6FJMD22z3kNTYLpsX3Oa2gSTI/tc15Dk2B6bJ/zGpoE02P7nNfQJJge2+e8hibB9Ng+5zU0CabH9jmvoUkwPbbPeQ1Ngumxfc5raBJMj+1zXkOTYHpsn/MamgTTY/uc19AkmB7b57yGJsH02D7nNTQJpsf2Oa+hSTA9ts95DU2C6bF9zmtoEkyP7XNeQ5Ngemyf8xqahNJj5dEHvcZGoXTZZxRKm31GofTZZxRKo31GoXTaZxRKq31GofTaZxRKs31G4XTbPvI1Ngqn2/ahr7FRON22j32NjcLptn3wa2wUTrfto19jo3C6bR/+GhuF0237+NfYKJxu2wfAxkbhdNs+AjY2Cqfb9iGwsVE43baPgY2Nwum2fRBsbBROt+2jYGOjcLotBoM9o3C6LYaDPaNwui0GhD2jcLothoQ9o3C6LQaFPaNwui2GhT2jcLotBoY9o3C6LYaGPaNwui0Ghz2jcLothoc9o3C6LQaIPaNwui2GiD2jcLotBok9o3C6LYaJPaNwui0Gij2jcLothoo9o3C6LQaLPaNwui2Giz2jcLotBow9o3C6LYaMPaNwui0GjT2jcLotho09o3C6LQaOPaNwui2Gjj2jcLotBo89o3C6LYaPPaNwui0GkD2jcLothpA9o3C6LQaRPaNwui2GkT2jcLotBpI9o3C6LYaSPaNguq1wLJlwLJlwLJlwLJk8MN1WOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOJZMOZZMOZZMOZZMOZZMH5huqxxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLphxLZhxLZhxLZhxLZhxLZg9MtzWOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJTOOJXOOJXOOJXOOJXOOJfMHpts6x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5I5x5IFx5IFx5IFx5IFx5LFA9Ntg2PJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJgmPJkmPJkmPJkmPJkmPJ8oHptsmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZMmxZI1jyRrHkjWOJWscS9YemG7bOJascSxZ41iyxrFkjWPJGseSNY4laxxL1jiWrHEsWeNYssaxZI1jyRrHkjWOJWscS9Y4lqxxLFnjWLLGsWSNY8kax5I1jiVrHEvWOJascSxZ41iyxrFkjWPJGseSNY4laxxL1jiWrHEsWeNYssaxZI1jyRrHkjWOJWscS9Y4lqxxLFnjWLLGsWSNY8kax5I1jiVrHEvWOJascSxZ41iyxrFkjWPJGseSNY4laxxL1jiWrHEsWeNYssaxZI1jyRrHkjWOJWscS9Y4lqxxLFnjWLLGsWSNY8kax5I1jiVrHEvWOJascSxZ41iyxrFkjWPJGseSNY4laxxL1jiWrHEsWeNYssaxZI1jyRrHkjWOJWscS9Y4lqxxLFnjWLLGsWSNY8kax5I1jiUrjiUrjiUrjiUrjiWrB6bbFseSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSFceSLRxLtnAs2cKxZAvHki0PTLddOJZs4ViyZduSaVvs9WPV2ueBSvX92fyIE7nxYbOWP3/YbFl++eFXoM2ee2Sgzc57YKBtXXZkoM0ufGSgzV58ZKDNjnxkoM2+fGSgze58ZKDNHn1kIFqn3tZoRwaideptmXZkIFqn3lZqRwaideptsXZkIFqn3tZrRwaideptyXZkIFqn3lZtRwaidepty/XdAoksP39WtN4freUd52u70G6cr/0NE3/9u+K+FWfA75c8PuLE53HU2qs86vJRn8W2sj9avcI/lvzlh39Ov42eTpN+wG/ugekHDGTfLb3I62aWiMVW+gHT24HpB7TYA9MP6MjfL33KO31bttIPGCIPTD9g4jww/YDD81fTv77j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",
      "eJzVndGOJLlxRf9lnhdGJYOMIPdXDD8ItgwIEGTD0puw/+4UVNU9xmZO8U4nI4+ftBgwm1fL4q3qU3Fm//7tz//173/425/+6y9//fbr3789/qWOb7/+69+//fW///CXf/zBX//2h//527dfH798++Nf/mP/399++faff/rzH7/9uv32b7/sy9tDW75py4u23LTlVVveZpf/8rtVm23ltXL/59o/Vtt4/nRf+tNj6U/vS3/69CvyZ366T7+Af+qnT7/ef+qnT1+Pn/rp07fpp3769OX7qZ++9K760rvqS++qL72rvvSuxtK7Gkvvaiy9q7H0rsbSuxpL72osvaux9K7G0rsaX7qr1sbHT7e+ff/Tj5b7wz6W+6P+Lkz/0tW+OsyXmuDqMF8qjqvDfKlnrg7zpVq6OsyXWuzqMF8qvavDfKkjrw7zpUq9OgypgQepgQepgQepgQepgQepgQepgQepgQepgQepgQepgbcHqYK3B6mDtwephLcHqYW3B6mGtweph7cHqYi3B6mJtwepircHqos3VBdvqC7eUF28obp4Q3XxhuriDdXFG6qLN1QXb6guLqguLqguLqguLqguLqguLqguLqguLqguLqguLqguNlQXG6qLDdXFhupiQ3WxobrYUF1sqC42VBcbqosrqosrqosrqosrqosrqosrqosrqosrqosrqovnTYWMNPMiREoaVBfPaxwpaVBdPC+hpKRBdfHXnJir03zNFFHTtM/hXY/tIE3qDX+bJvFVXO3zpPZ/PjqpxFdx3dd8phn9x8uHtefi0e1jabVX8MQX/LXBEz+nXBp8Xil5rtcExm1e+3iu1xTGbV7NeK6fvhrP9dOvyOf66RfCc/30R8rnek1P3ea9gud68Xznp/Of68XznZ9xf64Xz3d+Uvy5Xjzf+Xnr53rxfOenlp/rxfOdn/19rhfPd36C9rlePN/5OdTnevF856c5n+u18y3zI5HP9dr5lvmxwud67XzLQzvfMj8891yvnW+ZH0B7rtfOt8wPcf1z/fyY1XO9eL7zo0rP9eL5zo/7PNeL5zs/MvNcL57v/NjJc714vvOjG8/14vnOjz8814vnOz9C8Fwvnu/81/DP9eL5zn+V/Vwvnu/818HP9eL5zn+l+lwvnu/815LP9eL5zn+191wvnu/812PP9eL5zn/F9Fwvnu/81zTP9eL5zn/V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"
    ],
    "fileMap": {
      "1": {
        "source": "// everyone has 1 vote (maybe if its easy to implement 1 each) - we use counter\n// they vote yes or no on proposal which pluses or minuses another counter\n// proposal and vote exists in the constructor\n// admin who deploys is admin of contract and can call vote_ended\n// vote_ended is private and then sends result to public function, which updates public persistent state\n// then anyone can call that public function\nmod types;\ncontract Counter {\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n         state_vars::{\n            immutable_singleton::ImmutableSingleton, map::Map, public_state::PublicState, set::Set,\n            singleton::Singleton,\n        },\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::safe_math::SafeU120;\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n    use dep::field_note::field_note::{FieldNote, FieldNoteMethods, FIELD_NOTE_LEN};\n\n    use crate::types::{SafeU120SerializationMethods, SAFE_U120_SERIALIZED_LEN};\n\n\n\n    struct Storage {\n        counters: Map<EasyPrivateUint>,\n        // tally: Map<SafeU120>\n        tally: Map<PublicState<SafeU120, SAFE_U120_SERIALIZED_LEN>>\n    }\n\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n                    tally: Map::new(\n                    context,\n                    2,\n                    |context, slot| {\n                        PublicState::new(\n                            context,\n                            slot,\n                            SafeU120SerializationMethods,\n                        )\n                    },\n                ),\n\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor(proposal: Field, admin: Field) {\n\n    }\n\n\n    #[aztec(public)]\n      fn vote(owner: Field, vote: Field)  {\n        let amount = SafeU120::new(1);\n        let new_tally = storage.tally.at(vote).read().add(amount);\n        storage.tally.at(vote).write(new_tally)\n    }\n\n    unconstrained fn get_vote(vote: Field) -> u120 {\n        storage.tally.at(vote).read().value\n    }\n\n\n    unconstrained fn compute_note_hash_and_nullifier(\n    contract_address: Field,\n    nonce: Field,\n    storage_slot: Field,\n    preimage: [Field; VALUE_NOTE_LEN],\n    ) -> [Field; 4] {\n    let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n    note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/Users/spypsy/Dev/aztec/aztec-voting/contracts/voting/src/main.nr"
      },
      "20": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "21": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "36": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "39": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/abi.nr"
      },
      "40": {
        "source": "use crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  pedersen_hash([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)\n}",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/address.nr"
      },
      "42": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/context.nr"
      },
      "43": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/hash.nr"
      },
      "52": {
        "source": "use crate::hash::pedersen_hash;\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/note_hash.nr"
      },
      "56": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    serialized_note: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/note/utils.nr"
      },
      "63": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n  get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n  let result = get_public_key_and_partial_address_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/get_public_key.nr"
      },
      "64": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(\n    _owner: Point,\n) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/get_secret_key.nr"
      },
      "69": {
        "source": "\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(\n    _storage_slot: Field,\n    _number_of_elements: Field,\n) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field)-> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<T, N>(\n    storage_slot: Field,\n    deserialize: fn ([Field; N]) -> T,\n) -> T {\n    let fields = storage_read_oracle_wrapper(storage_slot);\n    deserialize(fields)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(\n    _storage_slot: Field,\n    _values: [Field; N],\n) -> [Field; N] {}\n\n// TODO: Remove return value.\nunconstrained pub fn storage_write<N>(\n    storage_slot: Field,\n    fields: [Field; N]\n) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/oracle/storage.nr"
      },
      "76": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/state_vars/map.nr"
      },
      "77": {
        "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse crate::types::type_serialization::TypeSerializationInterface;\nuse dep::std::option::Option;\n\n// docs:start:public_state_struct\nstruct PublicState<T, T_SERIALIZED_LEN> {\n    context: Context,\n    storage_slot: Field,\n    serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n}\n// docs:end:public_state_struct\n\nimpl<T, T_SERIALIZED_LEN> PublicState<T, T_SERIALIZED_LEN> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n        serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState {\n            context,\n            storage_slot,\n            serialization_methods,\n        }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read(self) -> T {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        storage_read(self.storage_slot, self.serialization_methods.deserialize)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write(self, value: T) {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let serialize = self.serialization_methods.serialize;\n        let fields = serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/state_vars/public_state.nr"
      },
      "89": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/aztec/src/utils.nr"
      },
      "93": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    pub fn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: serialized_note[1],\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(serialized_note)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/value-note/src/value_note.nr"
      },
      "96": {
        "source": "struct SafeU120 {\n    value: u120,\n}\n\nimpl SafeU120 {\n    pub fn min() -> Self {\n        Self {\n            value: 0\n        }\n    }\n\n    pub fn max() -> Self {\n        Self {\n            value: 0xffffffffffffffffffffffffffffff\n        }\n    }\n\n    pub fn new(\n        value: Field,\n    ) -> Self {\n        // Check that it actually will fit. Spending a lot of constraints here :grimacing:\n        let bytes = value.to_be_bytes(32);\n        for i in 0..17 {\n            assert(bytes[i] == 0, \"Value too large for SafeU120\");\n        }\n        Self {\n            value: value as u120\n        }\n    }\n\n    pub fn is_zero(\n        self: Self,\n    ) -> bool {\n        self.value == 0\n    }\n\n    pub fn eq(\n        self: Self,\n        other: Self\n    ) -> bool {\n        self.value == other.value\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.value < other.value\n    }\n\n    pub fn le(self: Self, other: Self) -> bool {\n        self.value <= other.value\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.value > other.value\n    }\n\n    pub fn ge(self: Self, other: Self) -> bool {\n        self.value >= other.value\n    }\n\n    pub fn sub(\n      self: Self,\n      b: Self,\n    ) -> Self {\n        assert(self.value >= b.value, \"Underflow\");\n        Self {\n            value: self.value - b.value\n        }\n    }\n\n    pub fn add(\n        self: Self,\n        b: Self,\n    ) -> Self {\n        let c: u120 = self.value + b.value;\n        assert(c >= self.value, \"Overflow\");\n        Self {\n            value: c\n        }\n    }\n\n    pub fn mul(\n        self: Self,\n        b: Self,\n    ) -> Self {\n        let c: u120 = self.value * b.value;\n        if !b.is_zero() {\n            assert(c / b.value == self.value, \"Overflow\");\n        }\n        Self {\n            value: c\n        }\n    }\n\n    pub fn div(\n        self: Self,\n        b: Self,\n    ) -> Self {\n        assert(!b.is_zero(), \"Divide by zero\");\n        Self {\n            value: self.value / b.value\n        }\n    }\n\n    pub fn mul_div(\n        self: Self,\n        b: Self,\n        divisor: Self\n    ) -> Self {\n        self.mul(b).div(divisor)\n    }\n\n    pub fn mul_div_up(\n        self: Self,\n        b: Self,\n        divisor: Self\n    ) -> Self {\n        let c = self.mul(b);\n        assert(!divisor.is_zero(), \"Divide by zero\");\n        let adder = ((self.value * b.value % divisor.value) as u120 > 0) as u120;\n        c.div(divisor).add(Self {value: adder})\n    }\n\n    // todo: implement mul_div with 240 bit intermediate values.\n}\n\n#[test]\nfn test_init() {\n    let a = SafeU120::new(1);\n    assert(a.value == 1);\n}\n\n#[test]\nfn test_init_max() {\n    let a = SafeU120::max();\n    assert(a.value == 0xffffffffffffffffffffffffffffff);\n}\n\n#[test]\nfn test_init_min() {\n    let a = SafeU120::min();\n    assert(a.value == 0);\n}\n\n#[test]\nfn test_is_zero() {\n    let a = SafeU120::min();\n    assert(a.value == 0);\n    assert(a.is_zero() == true);\n}\n\n#[test]\nfn test_eq() {\n    let a = SafeU120::new(1);\n    let b = SafeU120::new(1);\n    assert(a.eq(b));\n}\n\n#[test]\nfn test_lt() {\n    let a = SafeU120::new(1);\n    let b = SafeU120::new(2);\n    assert(a.lt(b));\n    assert(b.lt(a) == false);\n}\n\n\n#[test]\nfn test_le() {\n    let a = SafeU120::new(2);\n    let b = SafeU120::new(2);\n    let c = SafeU120::new(5);\n    assert(a.le(b));\n    assert(a.le(c));\n    assert(c.le(a) == false);\n}\n\n#[test]\nfn test_gt() {\n    let a = SafeU120::new(1);\n    let b = SafeU120::new(2);\n    assert(b.gt(a));\n    assert(a.gt(b) == false);\n}\n\n\n#[test]\nfn test_ge() {\n    let a = SafeU120::new(2);\n    let b = SafeU120::new(2);\n    let c = SafeU120::new(5);\n    assert(a.ge(b));\n    assert(a.ge(c) == false);\n    assert(c.ge(a));\n}\n\n#[test(should_fail)]\nfn test_init_too_large() {\n    let b = SafeU120::max().value as Field + 1; // max + 1\n    let _a = SafeU120::new(b);\n}\n\n#[test]\nfn test_add() {\n    let a = SafeU120::new(1);\n    let b = SafeU120::new(2);\n    let c = SafeU120::add(a, b);\n    assert(c.value == 3);\n}\n\n#[test(should_fail)]\nfn test_add_overflow() {\n    let a = SafeU120::max();\n    let b = SafeU120::new(1);\n    let _c = SafeU120::add(a, b);\n}\n\n#[test]\nfn test_sub() {\n    let a = SafeU120::new(2);\n    let b = SafeU120::new(1);\n    let c = SafeU120::sub(a, b);\n    assert(c.value == 1);\n}\n\n#[test(should_fail)]\nfn test_sub_underflow() {\n    let a = SafeU120::new(1);\n    let b = SafeU120::new(2);\n    let _c = SafeU120::sub(a, b);\n}\n\n#[test]\nfn test_mul() {\n    let a = SafeU120::new(2);\n    let b = SafeU120::new(3);\n    let c = SafeU120::mul(a, b);\n    assert(c.value == 6);\n}\n\n#[test(should_fail)]\nfn test_mul_overflow() {\n    let a = SafeU120::max();\n    let b = SafeU120::new(2);\n    let _c = SafeU120::mul(a, b);\n}\n\n#[test]\nfn test_div() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::div(a, b);\n    assert(c.value == 2);\n}\n\n#[test(should_fail)]\nfn test_div_by_zero() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(0);\n    let _c = SafeU120::div(a, b);\n}\n\n#[test]\nfn test_mul_div() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::new(2);\n    let d = SafeU120::mul_div(a, b, c);\n    assert(d.value == 9);\n}\n\n#[test(should_fail)]\nfn test_mul_div_zero_divisor() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::new(0);\n    let _d = SafeU120::mul_div(a, b, c);\n}\n\n#[test(should_fail)]\nfn test_mul_div_ghost_overflow() {\n    let a = SafeU120::max();\n    let b = SafeU120::new(2);\n    let c = SafeU120::new(4);\n    let _d = SafeU120::mul_div(a, b, c);\n}\n\n#[test]\nfn test_mul_div_up_rounding() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::new(5);\n    let d = SafeU120::mul_div_up(a, b, c);\n    assert(d.value == 4);\n}\n\n#[test]\nfn test_mul_div_up_non_rounding() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::new(2);\n    let d = SafeU120::mul_div_up(a, b, c);\n    assert(d.value == 9);\n}\n\n\n#[test(should_fail)]\nfn test_mul_div_up_ghost_overflow() {\n    let a = SafeU120::max();\n    let b = SafeU120::new(2);\n    let c = SafeU120::new(9);\n    let _d = SafeU120::mul_div_up(a, b, c);\n}\n\n// It should not be possible for us to overflow `mul_div_up` through the adder, since that require the divisor to be 1\n// since we otherwise would not be at the max value. If divisor is 1, adder is 0.\n#[test(should_fail)]\nfn test_mul_div_up_zero_divisor() {\n    let a = SafeU120::new(6);\n    let b = SafeU120::new(3);\n    let c = SafeU120::new(0);\n    let _d = SafeU120::mul_div_up(a, b, c);\n}\n",
        "path": "/Users/spypsy/nargo/github.com/AztecProtocol/aztec-nrmaster/safe-math/src/safe_u120.nr"
      },
      "97": {
        "source": "use dep::aztec::types::type_serialization::TypeSerializationInterface;\nuse dep::safe_math::SafeU120;\n\nglobal SAFE_U120_SERIALIZED_LEN: Field = 1;\n\n// This is safe when reading from storage IF only correct safeu120 was written to storage\nfn deserializeU120(fields: [Field; SAFE_U120_SERIALIZED_LEN]) -> SafeU120 {\n    SafeU120{value: fields[0] as u120}\n}\n\nfn serializeU120(value: SafeU120) -> [Field; SAFE_U120_SERIALIZED_LEN] {\n    [value.value as Field]\n}\n\nglobal SafeU120SerializationMethods = TypeSerializationInterface {\n    deserialize: deserializeU120,\n    serialize: serializeU120,\n};",
        "path": "/Users/spypsy/Dev/aztec/aztec-voting/contracts/voting/src/types.nr"
      }
    }
  }
}